========================
TotalJSON - ReadMe.txt
========================



JSON
====

Если вы не знакомы с самим форматом JSON, проверьте его http://json.org / первый.



Основное использование
===========

Этот пакет - не что иное, как код C# (исключая один пример сцены). Все общедоступные скрипты
находятся в папке TotalJSON/Scripts/

Используйте их в своем собственном коде:
с помощью Легуара.TotalJSON;

Классы, представляющие объекты и значения JSON, являются:
* JSON-основной класс объектов JSON, в котором данные сохраняются в виде пар ключ / значение
* Jarray-массив JSON, в котором доступ к данным осуществляется по индексу
* JString - строковое значение
* JNumber - числовое значение (целое число или число с плавающей запятой)
* JBoolean - логическое (bool) значение
* JNull - нулевое значение JSON

Папка Scripts также содержит JValue, который является просто абстрактным базовым классом для всех вышеперечисленных классов
и обычно не используется напрямую.

JSON и JArray отличаются от других в том смысле, что они могут быть изменены после создания экземпляра.
Вы можете использовать предоставленные методы для добавления, удаления и замены значений в них.


Создание и изменение
----------------------

Вы можете создать новый объект JSON
JSON с помощью JSON = JSON с новой();
и используйте предоставленный метод для добавления/изменения/удаления данных.

Массивы могут быть созданы аналогично
JArray jArray = новый JArray();

Обычно значения добавляются непосредственно к объектам JSON или JArray, таким как
json.Add("answer",42);
или
jArray.Добавить(правда);

Все методы Add, Replace, Insert и т. д. принимают "объект" в качестве входного параметра. Этот
объект может быть чем угодно, что может быть преобразовано в некоторый объект JValue без какой-либо двусмысленности.
Например, строки, любые типы чисел C#, логические значения и null. Очевидно, что другие объекты JSON
или массивы JArray тоже хороши.

Но JSON-число, строка, логическое и NULL-значений могут быть созданы отдельно
JNumber jsonNumber = new JNumber(42);
а затем добавляется к объектам JSON или JArray.

Это полезно, особенно с числами, которые выходят за пределы обычного диапазона чисел C# :
json. Add("huge_integer", new JNumber ("123456789012345678901234567890"));
или
jArray.InsertAt(0, new JNumber("3.1415 E+42000"));


Синтаксический анализ и создание строк в формате JSON
-------------------------------------------

Строки, которые находятся в формате JSON, например
{"name": "Pingu", "active": true, "items": [1,2,4]}
может быть превращен в объект JSON с помощью статического метода
JSON json = JSON. ParseString(inputString);

Аналогично, объект JSON можно превратить в строку в формате JSON
, используя string outputString = json.CreateString();
обычно для хранения или отправки в другую систему.

Существует также способ получить JSON в более удобном для человека формате с помощью
Отладки.Журнала(в формате JSON.CreatePrettyString());
как правило, для целей отладки.

То же самое можно сделать и с Джарреем.


Распечатка значений
-------------------

Все классы (JSON, JArray, JString, JNumber, JBoolean и JNull) имеют ToString()
метод переопределен для вывода информации об объекте. В случае JSON, amount или пар
ключ/значение в объекте. В случае JArray-количество объектов и их типов или просто
значение, хранящееся в объекте. Как правило, хорошо подходит для консольного вывода.

Все классы также имеют метод CreateString (), который будет распечатывать все содержимое
объекта в формате JSON.


Сериализация и десериализация объектов
-------------------------------------

Например, если у вас есть класс типа
class ExamplePlayer {
public string name;
public bool active;
общедоступного списка<интервал> элементы;
}
и экземпляр 'examplePlayer' того класса, где поля "name", "active" и "items" имеют
некоторые заданные значения.

Вы можете превратить содержимое класса в JSON
JSON json = JSON.Сериализация (examplePlayer);
И это можно превратить в строку с помощью метода CreateString (), как в примере выше.

Только открытые поля и поля, помеченные атрибутом [UnityEngine.SerializeField] или
[IncludeToJSONSerialize] сериализуются. Постоянные, статические и только для чтения поля
не сериализуются. Кроме того, вы можете исключить открытые поля из сериализации с помощью
добавление к нему атрибута [System.NonSerialized] или [ExcludeFromJSONSerialize].

В другом направлении, если у вас есть входная строка типа
{"name": "Pingu", "active": true, "items": [1,2,4]}

Затем строковые значения можно скопировать в поля класса, сначала превратив string в JSON
JSON json = JSON. ParseString(inputString);
и десериализовать JSON в экземпляр класса
ExamplePlayer examplePlayer = формат JSON.Десериализация<ExamplePlayer>();

Теперь у вас есть экземпляр класса ExamplePlayer, где поле 'name' - это "Pingu" и т. д.



Дополнительные функции
===================


Отладка в редакторе Unity
-------------------------

Для удобства отладки вы можете следить за содержимым объектов JSON в редакторе Unity во
время работы приложения.

В вашем коде вы можете добавить любой объект JSON или JArray для отладки, сказав myJsonObject
.DebugInEditor ("мой объект JSON");
где строка параметра - это имя, которое появится в окне отладки.

В редакторе Unity откройте окно отладки из меню
Окно -> общее в JSON -> JSON и во время выполнения отладки

Там появятся ваши объекты и их содержимое.

Нет никакого вреда в том, чтобы оставить эти строки "DebugInEditor(...)" в вашем коде при создании сборки.
Они не имеют никакого эффекта вне редактора Unity.


Отладка в производстве
-----------------------

Ничто не идеально, и может случиться так, что данные JSON, которые вы пытаетесь разобрать или обработать,
недействительны. В редакторе это не такая уж большая проблема но в производственных сборках все что вы можете
получить это исключение как например

> JSONKeyNotFoundException: значение для ключа "id" не существует в этом JSON

В зависимости от сборки может оказаться, что нет никакой доступной трассировки стека. Если ваш
проект действительно обрабатывает много объектов JSON, приведенное выше сообщение об ошибке может вообще не сказать вам,
где возникла проблема.

Поэтому TotalJSON позволяет добавлять отладочный код в JSON-объекты. Например:

JSON playerJSON = getPlayerJSONFromServerData();
плейерджсон.SetDebugIDForExceptions("данные игрока с сервера");

Если теперь при обработке 'playerJSON' возникнут какие-либо исключения, то они будут выглядеть следующим образом:

> JSONKeyNotFoundException: значение для ключа "id" не существует в этом JSON-JSON Debug ID: "данные игрока с сервера"

Таким образом, вы сразу же узнаете, какой JSON вызвал исключение, даже если stacktrace недоступен.


Эта строка идентификатора отладки может быть добавлена уже при разборе JSON:

string playerDataString = <данные в формате json здесь>
JSON playerJSON = JSON. ParseString(playerDataString, " данные игрока с сервера");

В этом случае идентификатор отладки уже добавляется к исключениям, если они возникают при синтаксическом анализе
Данные JSON. Если синтаксический анализ идет нормально, то тот же самый идентификатор отладки (в данном случае "данные игрока с
сервера") добавляется к результирующему объекту JSON, так что нет необходимости использовать
SetDebugIDForExceptions(string) отдельно.


Валидатор JSON
--------------

Откройте JSON validator из меню редактора Unity
Окно - > Total JSON -> JSON Validator

В это окно вы можете скопировать и вставить объекты JSON или массивы и нажать кнопку Проверить ниже.
Это не только проверит, что JSON находится в допустимом формате, но и сделает его гораздо более
читабельным, добавив отступы и каналы строк.

Валидатор также приложит дополнительные усилия, пытаясь удалить начальные или конечные тексты, которые
не являются частью объекта JSON. Таким образом, вы можете, например, копировать текст непосредственно из консоли Unity с
помощью трассировок стека. До тех пор, пока в тексте есть какой-то объект JSON.


Настраиваемый вывод строки
------------------------

При превращении объекта JSON в строку с помощью метода CreateString () можно настроить
выходную строку с помощью CreateStringSettings.

строка customOutput = json.CreateString( new CreateStringSettings() {
HumanReadable = true,
NewLine = CreateStringSettings.NewLineTypes.Если
});

В основном это необходимо при выводе читаемого человеком JSON. CreateStringSettings позволяет,
например, изменять тип и размер отступа, символ, используемый для подачи строки и т. д.


Защита объектов JSON
-----------------------

Вы можете установить объекты JSON или JArray защищенными с помощью
в формате JSON.SetProtected();

Это установит этот объект JSON и все другие объекты, которые он содержит, защищенными от записи.
Ничего нельзя добавить, переместить или изменить. Это полезно, чтобы убедиться, что никакие случайные изменения не
вносятся в объекты, которые должны быть только для чтения.

После этого, соблюдение не может быть удален.




Примеры
========


Пакет TotalJSON имеет примеры каталогов, которые содержат примеры сцен и несколько примеров
сценариев.



Полные документы API
=============


Все классы имеют полную встроенную документацию по C#, которая также доступна онлайн в формате HTML:

http://www.leguar.com/unity/totaljson/apidoc/1.6/



Обратная связь
========


Если вы довольны этим активом, пожалуйста, оцените нас или оставьте отзыв в Unity Asset Store:

https://assetstore.unity.com/packages/slug/130344


Если у вас есть какие-либо проблемы или, возможно, предложения по будущим версиям, не стесняйтесь обращаться к нам:

http://www.leguar.com/contact/?about=totaljson